/*  VIDEOMAX CLASS  Version: 1.8 Date:    10/18/2010 AS Lang: 3.0  Author:  Anthony Hessler (Hessler Design) Web:     www.hesslerdesign.com Email:   anthony@hesslerdesign.com  	_______________                LICENSE:  _______________ 	VideoMax is licensed under a Creative Commons Attribution-ShareAlike 3.0 Unported License.	For more information about this license, visit: http://creativecommons.org/licenses/by-sa/3.0/ _______________                DESCRIPTION:  _______________ 	VideoMax is a very lightweight, fast, flexible, and easy-to-implement custom Flash video player	class that can be used in any ActionScript 3.0 file. It currently supports FLV and F4V file formats.	Some of the key highlights of the VideoMax class are:				- Lightweight: Importing and creating a VideoMax instance adds only 12kb to overall file		  weight. Compare that to the built-in Adobe 'flvPlayback' component, which adds 58kb to the		  overall file weight. Do the math. That's nearly 500% heavier than this VideoMax class.				- Easy to Use: With just 3 lines of code, you can import the VideoMax class, create an instance		  of the player, and add it to your Flash file. And because of its dynamically-built nature, there		  are NO Library components needed. That's right, NONE. All of the assets included in the VideoMax 		  class are 100% built from scratch with nothing but ActionScript 3.0 code.				- Customizable: You can change a number of attributes to your VideoMax instances, so you can have		  a video player that is as unique as the video it plays. The customizable attributes include		  Width, Height, Auto Load, Auto Play, Auto Rewind, Auto Size, Buffer, Looping, Control Bar visibility, 		  Tint, Play Button overlay, End Frame visibility, and onStart/onComplete listeners.				- Communicative: By using the onStart and onComplete listener attributes (and accompanying parameter		  attributes), you can have VideoMax dispatch events that call functions back in the parent file 		  when the video starts and/or ends.				- Self-Sufficient: With its robust set of default attributes, VideoMax takes care of wrapping		  up all of the loose ends. Once you create your VideoMax instance, you can sit back and relax,		  knowing that everything is taken care of, including control bar resizing and positioning, buffering, 		  automatic video resizing within the player, and more. Just import the class, create the instance, 		  assign it attributes, and add it to your file. VideoMax will take care of the rest for you._______________                PARAMETERS:   _______________  	VideoMax only takes 1 parameter, an Object, which is optional. This Object contains the specific 	(and optional) attributes to set in the VideoMax instance. The available attributes are:						- autoLoad (Boolean)         - If true, video will start loading upon instantiation. If false, video will not begin to load until play() is called. This value will be overwritten by a true value for autoPlay. (Default = true)		- autoPlay (Boolean)         - If true, will auto play the video. (Default = false)		- autoRewind (Boolean)       - If true, will seek to the video start when the video is done. (Default = true)		- autoSize (Boolean)         - If true, will automatically and proportionally scale the video inside the player. (Default = true)		- buffer (Number)            - Number of seconds of buffer needed before the video plays. (Default = 3)		- loop (Boolean)             - If true, video will auto-rewind (despite the autoRewind setting) and continue to loop playback. (Default = false)		- showControls (Boolean)     - If true, control bar is visible and active. (Default = true)		- showMiniStatus (Boolean)   - If true, mini status bar is visible when the control bar animates out. (Default = true)		- source (String)            - The path to the video that you want to play. (Default = null)		- tint (Array of uint)       - Array containing optional uint hex codes to tint (1) the control bar background elements, and (2) the control bar buttons and text elements. (Default = [0x000000, 0xffffff])		- height (Number)            - The height of the VideoMax instance. (Default = 480)		- width  (Number)            - The width of the VideoMax instance. (Default = 640)		- playOverlay (Boolean)      - If true, shows large Play button overlay over video when not playing. (Default = false)		- showFirstFrame (Boolean)   - If false, and autoPlay is false, hides video's first frame. (Default = true)		- showLastFrame (Boolean)    - If false, and autoRewind is false, hides video's last frame. (Default = true)		- showEndFrames (Boolean)    - If false, and autoPlay and autoRewind are false, hides video's first and last frames. Cancels out showFirstFrame and showLastFrame values, if set differently. (Default = true)		- onComplete (Function)      - Function in parent file to be called when video completes. (Default = null)		- onCompleteParams (Array)   - Array to pass in to onComplete function in parent file. (Default = null)		- onStart (Function)         - Function in parent file to be called when video starts. (Default = null)		- onStartParams (Array)      - Array to pass in to onStart function in parent file. (Default = null)		- enableFullScreen (Boolean) - If set to true, will include 'full screen' button in control bar, and add stage resize listeners. Note that if this is set to 'true', the 'allowFullScreen' parameter in your HTML embed code MUST be set to 'true' to properly work. Also, a very important note for full screen is that if it's set to 'true', the VideoMax object should be the ONLY object on your stage, as it will auto-resize to the dimensions of the stage._________________                PUBLIC METHODS: _________________	With VideoMax, you can call a number of public methods from the parent file. These methods are	outlined below.			- play():			Resets the buffer, and reloads the video from the source location. Use when 			updating buffer length, or changing the source location for your video.						 		- resume():			Resumes playback from the current playhead location. Use when the video has			been paused or stopped, as it will NOT completely reload the video like the			play() method does.						 		- pause():			Pauses playback.					- stop():			Stops playback and returns the playhead to the beginning of the video. Since			there is no built-in stop button in the Control Bar, use this method for 			stopping and resetting the video to the start.				- reset():			Stops playback, resets source to null, and hides video.					- mute(Boolean):			Mutes/Unmutes sound, based on the passed Boolean value into the function.			A 'true' value mutes sound. A 'false' value unmutes sound.				- getElapsed():			Returns the elapsed time as a Number.					- getDuration():			Returns the duration of the video as a Number.				- setSize(width, height):			Sets video width and height, which are passed in as parameters.			Passed width and height need to be typed as Numbers. (Default = 640, 480)				- setAutoLoad(Boolean):			If true, video will start loading upon instantiation. If false, video will			not begin to load until play() is called. This value will be overwritten by a			true value for autoPlay. (Default = true)					- setAutoPlay(Boolean):			If true, sets video to auto play. (Default = false)					- setAutoRewind(Boolean):			If true, video seeks to the start when the video is done. (Default = true)					- setAutoSize(Boolean):			If true, video will automatically and proportionally scale the 			video inside the player. (Default = true)					- setLoop(Boolean):			If true, video will auto-rewind (despite the autoRewind setting) 			and continue to loop playback. (Default = false)					- setTint(cbHex,btnHex):			Sets Control Bar tint. Passed parameters are uint values for (1) background 			elements, and (2) button and text elements. (Default = 0x000000, 0xffffff)				- setVolume(Number):			Sets volume level. A setting of 0 is mute, and 1 is 100%. This value can be 			more than 1, though audio quality may suffer. (Default = 1)					- setBuffer(Number):			Sets the number of seconds of buffer needed before the video plays. (Default = 3)				- showVideo(Boolean):			Shows/Hides video inside of player. (Default = true)					- showControlBar(Boolean):			Shows/Hides control bar inside of player. (Default = true)				- showMiniStatusBar(Boolean):			Shows/Hides mini status bar that shows when control bar is not visible. (Default = true)_______________                INSTRUCTIONS: _______________  	To use VideoMax in your Flash project, you must import the VideoMax class into your file,	create a new instance, and add it to the display list. 	 	Setting VideoMax attributes can be done in two different ways, as seen in the two examples outlined below.  		1) Setting Object Attributes on Creation (RECOMMENDED): 		 				import com.hd.VideoMax; 				var vm:VideoMax = new VideoMax({width:640, height:480, autoLoad:true, autoPlay:true, autoRewind:true, autoSize:true, buffer:10, loop:true, playOverlay:true, showControls:true, showMiniStatus:true, tint:[0x1c1c1c, 0xffffff], source:"sample.flv", showFirstFrame:true, showLastFrame:true, showEndFrames:true, onStart:helloWorld, onStartParams:["array", "of", "params"], onComplete:helloWorld, onCompleteParams:["array", "of", "params"]}); 				addChild(vm);						2) Setting Individual Attributes After Creation: 		 				import com.hd.VideoMax;				var vm:VideoMax = new VideoMax(); 				vm.setSize(640, 480); 				vm.setTint(0x1c1c1c, 0xffffff);				vm.autoLoad = true;   // OR vm.setAutoLoad(true); 				vm.autoPlay = true;   // OR vm.setAutoPlay(true); 				vm.autoRewind = true; // OR vm.setAutoRewind(true); 				vm.autoSize = true;   // OR vm.setAutoSize(true);				vm.buffer = 10;       // OR vm.setBuffer(10);				vm.loop = true;       // OR vm.setLoop(true);				vm.playOverlay = true;				vm.showControls = true;				vm.showMiniStatus = true;				vm.showFirstFrame = false;				vm.showLastFrame = false;				vm.showEndFrames = false; 				vm.source = "sample.flv"; 				vm.play();				addChild(vm);				** NOTE: In Example 2, vm.play() needs to be called AFTER setting the attributes, even if the 		   autoPlay attribute is set to true. This is because the autoPlay attribute's default value is set		   to 'false'. So when the VideoMax object is set, it will NOT play the video until instructed.		   Also, since you are setting attributes after creating the VideoMax instance, the attributes		   need to be recalculated, which happens when the 'play()' function is called. Lastly, if using		   Example 2, you do not have the ability to add 'onStart' and 'onComplete' commands, along with 		   their accompanying parameters, unless you pass them as part of the attributes when creating the 		   VideoMax instance._______________                CHANGE LOG: _______________  	1.8:		- Added playOverlay(true) functionality into stop() function.	1.7:		- Fixed autoPlay override issue on movies using VM objects with sizes smaller than		  their own stage dimensions. This had caused ALL movies w/in the VM player to autoPlay,		  even when not intentional.	1.6:		- Added full screen option for control bar.	1.5:		- Added mini status bar and 'showMiniStatus' attribute.	1.4:		- Added public 'setVolume' function.		- Added public 'reset' function.	1.3:		- Added autoLoad and setAutoLoad logic.	1.2:		- Added playOverlay parameter, and accompanying PlayOverlay class. Also updated Slider		  class to fix coordinate attributes set to 0,which had been reading attribute as false,		  rather than as a number.	1.1:		- Added documentation on public methods, and updated default parameters of public methods. 		  Also added getElapsed() and getDuration() methods, and the custom context menu.	1.0:		- Initial Release.	*/package com.hd {		import flash.display.*;	import flash.events.ContextMenuEvent;	import flash.events.Event;	import flash.events.IOErrorEvent;	import flash.events.MouseEvent;	import flash.events.NetStatusEvent;	import flash.events.TimerEvent;	import flash.media.SoundTransform;	import flash.media.Video;	import flash.net.navigateToURL;	import flash.net.NetConnection;	import flash.net.NetStream;	import flash.net.URLRequest;	import flash.ui.ContextMenu;	import flash.ui.ContextMenuItem;	import flash.utils.Timer;	import flash.geom.Rectangle;	import com.hd.videomax.assets.*;	import com.hd.videomax.transitions.*;		public class VideoMax extends Sprite {				// Public Properties		public var source:String;		public var autoLoad:Boolean = true;		public var autoPlay:Boolean = false;		public var autoRewind:Boolean = true;		public var autoSize:Boolean = true;		public var buffer:Number = 3;		public var loop:Boolean = false;		public var showControls:Boolean = true;		public var showMiniStatus:Boolean = true;		public var showFirstFrame:Boolean = true;		public var showLastFrame:Boolean = true;		public var showEndFrames:Boolean = true;		public var playOverlay:Boolean = false;				// Private Properties		private var player:Sprite = new Sprite();		private var video:Video;		private var videoBG:Sprite;		private var videoMask:Sprite;		private var nc:NetConnection;		private var ns:NetStream;		private var controlBar:ControlBar;		private var miniStatusBar:MiniStatusBar;		private var po:PlayOverlay;		private var rcMenu:ContextMenu;		private var cbHex:uint = 0x000000;		private var btnHex:uint = 0xffffff;		private var audioLevel:int = 1;		private var metaObj:Object;		private var isPlaying:Boolean = false;		private var hasLoaded:Boolean = false;		private var fullScreenEnabled:Boolean = false;		private var isFullScreen:Boolean = false;		private var lbw_num:Number;		private var vw_num:Number = 640;		private var vh_num:Number = 480;		private var cbTimer:Timer;		private var loaded_num:Number;		private var duration_num:Number;		private var bounds_rect:Rectangle = new Rectangle();		private var att:Object = new Object();		private var maskCreated:Boolean = false;		private var videoCreated:Boolean = false;		private var playOverlayCreated:Boolean = false;		private var controlBarCreated:Boolean = false;		private var contextMenuCreated:Boolean = false;		private var requiredSteps_arr:Array = [maskCreated, videoCreated, playOverlayCreated, controlBarCreated, contextMenuCreated];		private const VIDEO_MAX_URL:String = "http://www.hesslerdesign.com/videomax/";						public function VideoMax(pAttributes:Object=null):void {			if (pAttributes) {				// Set local 'att' to passed value, if it exists				att = pAttributes;			}			this.addEventListener(Event.ADDED_TO_STAGE, onAddedToStage);		}								// --- Public: Playback Control Functions --- //		public function play():void {			if (source != null) {				if (!hasLoaded) {					if (!autoPlay) {						if (autoLoad) {							if ((!showFirstFrame) || (!showEndFrames)) {								showVideo(false);							} else {								showVideo(true);							}							ns.play(source);							hasLoaded = true;							pause();							ns.seek(0);						}					} else {						showVideo(true);						ns.play(source);						hasLoaded = true;						pause();						resume();						controlBar.showControls("pause");					}				} else {					resume();				}			}		}		public function resume():void {			if(source != null){				if (!hasLoaded) {					ns.play(source);					hasLoaded = true;					pause();					resume();				} else {					if ((ns.time < 0.1) || (ns.time > (duration_num - 0.1))) {						ns.seek(0);						onVideoStart();					}					ns.resume();				}				showVideo(true);				isPlaying = true;				controlBar.showControls("pause");				showPlayOverlay(false);			}		}		public function pause():void {			ns.pause();			isPlaying = false;			controlBar.showControls("play");			showPlayOverlay(true);		}		public function stop():void {			pause();			ns.seek(0);			showPlayOverlay(true);		}		public function mute(pWhatWay_bol:Boolean=true):void {			if (pWhatWay_bol) {				controlBar.muteBtn.mute();				setAudioLevel(0);			} else {				controlBar.muteBtn.mute(false);				setAudioLevel(1);			}		}		public function setFullScreen(pWhatWay_bol:Boolean=true):void {			if (pWhatWay_bol) {				isFullScreen = true;				controlBar.fullScreenBtn.setFullScreen(true);				stage.displayState = StageDisplayState.FULL_SCREEN;			} else {				isFullScreen = false;				controlBar.fullScreenBtn.setFullScreen(false);				stage.displayState = StageDisplayState.NORMAL;			}		}		public function reset():void {			stop();			source = null;			hasLoaded = false;			showVideo(false);		}								// --- Public: Visibility Functions --- //		public function showVideo(pWhatWay_bol:Boolean=true):void {			video.visible = pWhatWay_bol;		}		public function showControlBar(pWhatWay_bol:Boolean=true):void {			controlBar.visible = pWhatWay_bol;		}		public function showMiniStatusBar(pWhatWay_bol:Boolean=true):void {			miniStatusBar.visible = pWhatWay_bol;		}								// --- Public: GET/SET Functions --- //		public function setSize(pWidth_num:Number=640, pHeight_num:Number=480):void {			setWidth(pWidth_num);			setHeight(pHeight_num);			positionControlBar();			po.setSize(pWidth_num, pHeight_num);			sizeVideo(vw_num, vh_num);		}		public function setAutoLoad(pWhatWay_bol:Boolean=true):void {			autoLoad = pWhatWay_bol;		}		public function setAutoPlay(pWhatWay_bol:Boolean=false):void {			autoPlay = pWhatWay_bol;		}		public function setAutoRewind(pWhatWay_bol:Boolean=true):void {			autoRewind = pWhatWay_bol;		}		public function setAutoSize(pWhatWay_bol:Boolean=true):void {			autoSize = pWhatWay_bol;		}		public function setLoop(pWhatWay_bol:Boolean=false):void {			loop = pWhatWay_bol;		}		public function setTint(pCbHex:uint=0x000000, pBtnHex:uint=0xffffff):void {			cbHex = pCbHex;			btnHex = pBtnHex;			controlBar.tint(cbHex, btnHex);		}		public function setVolume(pNumber_num:Number=1):void {			setAudioLevel(pNumber_num);		}		public function setBuffer(pBuffer_num:Number=3):void {			buffer = pBuffer_num;			if (duration_num < buffer) {				buffer = (duration_num/3);			}			ns.bufferTime = buffer;			onVideoStatus(null);		}		public function getDuration():Number {			return duration_num;		}		public function getElapsed():Number {			return ns.time;		}								// --- Private: Initialization Functions --- //		private function onAddedToStage(e:Event):void {			setLocalAttributes();			init();		}		private function init():void {			if (fullScreenEnabled) {				stage.scaleMode = StageScaleMode.NO_SCALE;				stage.align = StageAlign.TOP_LEFT;				stage.addEventListener(Event.RESIZE, resizeHandler);			}			createMask();			createVideo();			createPlayOverlay();			createControlBar();			createContextMenu();			if (fullScreenEnabled) {				setFullScreen(false);			} 			addEventListener(Event.ENTER_FRAME, feedTheMachine);		}		private function feedTheMachine(e:Event):void {			var allSet:Boolean = true;			requiredSteps_arr = [maskCreated, videoCreated, playOverlayCreated, controlBarCreated, contextMenuCreated];			//trace("Machine Required Values: " + requiredSteps_arr);						for (var i=0; i<requiredSteps_arr.length; i++) {				if (!requiredSteps_arr[i]) {					allSet = false;					//trace("Not ready to go yet.");					break;				}			}			if (allSet) {				//trace("All systems go.");				setSize(vw_num, vh_num);				addChild(player);				play();				removeEventListener(Event.ENTER_FRAME, feedTheMachine);			}		}								// --- Private: Resize Handling --- //		private function resizeHandler(e:Event):void {			//trace("From resizeHandler, BEFORE setSize call: " + vw_num, vh_num, stage.stageWidth, stage.stageHeight);			setSize(stage.stageWidth, stage.stageHeight);		}								// --- Private: Get/Set Functions --- //		private function setLocalAttributes():void {			if (att.width != null) {				vw_num = att.width;			}			if (att.height != null) {				vh_num = att.height;			}			if (att.autoLoad != null) {				autoLoad = att.autoLoad;			}			if (att.autoPlay != null) {				autoPlay = att.autoPlay;			}			if (att.autoRewind != null) {				autoRewind = att.autoRewind;			}			if (att.autoSize != null) {				autoSize = att.autoSize;			}			if (att.buffer != null) {				buffer = att.buffer;			}			if (att.loop != null) {				loop = att.loop;			}			if (att.source != null) {				source = att.source;			}			if (att.tint != null) {				if (att.tint[0] != null) {					cbHex = att.tint[0];				}				if (att.tint[1] != null) {					btnHex = att.tint[1];				}			}			if (att.showControls != null) {				showControls = att.showControls;			}			if (att.showMiniStatus != null) {				showMiniStatus = att.showMiniStatus;			}			if (att.showFirstFrame != null) {				showFirstFrame = att.showFirstFrame;			}			if (att.showLastFrame != null) {				showLastFrame = att.showLastFrame;			}			if (att.showEndFrames != null) {				showEndFrames = att.showEndFrames;			}			if (att.playOverlay != null) {				playOverlay = att.playOverlay;			}			if (att.enableFullScreen != null) {				fullScreenEnabled = att.enableFullScreen;			}		}								// --- Private: Add/Remove Listener Functions --- //		private function addControlBarListeners(pWhatWay_bol:Boolean=true):void {			controlBar.statusBar.hit.buttonMode = pWhatWay_bol;			controlBar.statusBar.hit.useHandCursor = pWhatWay_bol;			if (pWhatWay_bol) {				controlBar.statusBar.hit.addEventListener(MouseEvent.MOUSE_OVER, onStatusBarMouseOver);				controlBar.statusBar.hit.addEventListener(MouseEvent.MOUSE_OUT, onStatusBarMouseOut);				controlBar.statusBar.hit.addEventListener(MouseEvent.MOUSE_MOVE, onStatusBarMouseMove);				controlBar.statusBar.hit.addEventListener(MouseEvent.CLICK, onStatusBarClick);				controlBar.statusBar.hit.addEventListener(MouseEvent.MOUSE_DOWN, onScrubberDown);				controlBar.playBtn.addEventListener(MouseEvent.CLICK, onPlayClick);				controlBar.pauseBtn.addEventListener(MouseEvent.CLICK, onPauseClick);				controlBar.muteBtn.addEventListener(MouseEvent.CLICK, onMuteClick);				if (fullScreenEnabled) {					controlBar.fullScreenBtn.addEventListener(MouseEvent.CLICK, onFullScreenClick);				}				addEventListener(MouseEvent.MOUSE_MOVE, determineControlBarPosition);				determineControlBarPosition(null);			} else {				controlBar.statusBar.hit.removeEventListener(MouseEvent.MOUSE_OVER, onStatusBarMouseOver);				controlBar.statusBar.hit.removeEventListener(MouseEvent.MOUSE_OUT, onStatusBarMouseOut);				controlBar.statusBar.hit.removeEventListener(MouseEvent.MOUSE_MOVE, onStatusBarMouseMove);				controlBar.statusBar.hit.removeEventListener(MouseEvent.CLICK, onStatusBarClick);				controlBar.statusBar.hit.removeEventListener(MouseEvent.MOUSE_DOWN, onScrubberDown);				controlBar.playBtn.removeEventListener(MouseEvent.CLICK, onPlayClick);				controlBar.pauseBtn.removeEventListener(MouseEvent.CLICK, onPauseClick);				controlBar.muteBtn.removeEventListener(MouseEvent.CLICK, onMuteClick);				if (fullScreenEnabled) {					controlBar.fullScreenBtn.removeEventListener(MouseEvent.CLICK, onFullScreenClick);				}				removeEventListener(MouseEvent.MOUSE_MOVE, determineControlBarPosition);				controlBar.y = videoBG.y + videoBG.height;			}		}		private function addVideoStatusListener(pWhatWay_bol:Boolean=true):void {			if (pWhatWay_bol) {				addEventListener(Event.ENTER_FRAME, onVideoStatus);			} else {				removeEventListener(Event.ENTER_FRAME, onVideoStatus);			}		}		private function addScrubbitListener(pWhatWay_bol:Boolean=true):void {			if (pWhatWay_bol) {				addEventListener(Event.ENTER_FRAME, scrubit);			} else {				removeEventListener(Event.ENTER_FRAME, scrubit);			}		}								// --- Private: Create Functions --- //		private function createMask():void {			videoMask = new Sprite();			videoMask.graphics.beginFill(0xffffff, 0);			videoMask.graphics.drawRect(0, 0, vw_num, vh_num);			videoMask.graphics.endFill();			player.addChild(videoMask);			player.mask = videoMask;						// Set to TRUE for machine			maskCreated = true;		}		private function createVideo():void {			videoBG = new Sprite();			videoBG.graphics.beginFill(0x000000, 1);			videoBG.graphics.drawRect(0, 0, vw_num, vh_num);			videoBG.graphics.endFill();						nc = new NetConnection();			nc.connect(null);			ns = new NetStream(nc);			metaObj = new Object();			ns.client = metaObj;			ns.addEventListener(NetStatusEvent.NET_STATUS, onStatusEvent);			ns.addEventListener(IOErrorEvent.IO_ERROR, onIOError);									video = new Video(vw_num, vh_num);			video.smoothing = true;						video.attachNetStream(ns);			metaObj.onMetaData = onMetaHandler;						player.addChildAt(videoBG, 0);			player.addChildAt(video, 1);						showVideo(false);						// Set to TRUE for machine			videoCreated = true;					}		private function createControlBar():void {			controlBar = new ControlBar(cbHex, btnHex, fullScreenEnabled);			miniStatusBar = new MiniStatusBar(cbHex, btnHex);			addVideoStatusListener(true);			addControlBarListeners(true);			onStatusBarMouseOut(null);			showControlBar(showControls);			showMiniStatusBar(showMiniStatus);			setTint(cbHex, btnHex);			player.addChild(controlBar);			player.addChild(miniStatusBar);						// Set to TRUE for machine			controlBarCreated = true;		}		private function createContextMenu():void {			rcMenu = new ContextMenu();			rcMenu.hideBuiltInItems();			var vmURL = new ContextMenuItem("VideoMax - Copyright 2010");			vmURL.enabled = false;			rcMenu.customItems.push(vmURL);			contextMenu = rcMenu;						// Set to TRUE for machine			contextMenuCreated = true;		}		private function createPlayOverlay():void {			po = new PlayOverlay(vw_num, vh_num);			po.addEventListener(MouseEvent.CLICK, onPlayOverlayClick);			player.addChild(po);						// Set to TRUE for machine			playOverlayCreated = true;		}								// --- Private: Get/Set Functions --- //		private function setWidth(pSize_num:Number):void {			// Setting vw_num here messes up aspect ratio going into full screen			//vw_num = pSize_num;			videoBG.width = videoMask.width = pSize_num;			controlBar.setWidth(pSize_num);			miniStatusBar.setWidth(pSize_num);		}		private function setHeight(pSize_num:Number):void {			// Setting vh_num here messes up aspect ratio going into full screen			//vh_num = pSize_num;			videoBG.height = videoMask.height = pSize_num;			positionControlBar();		}		private function setAudioLevel(pNum_num:Number):void {			ns.soundTransform = new SoundTransform(pNum_num);			audioLevel = pNum_num;			if (pNum_num > 0) {				controlBar.muteBtn.mute(false);			} else {				controlBar.muteBtn.mute();			}		}								// --- Private: Event Listener Functions --- //		public function onMetaHandler(pObj:Object):void {			/*			// For Debug ONLY //			for (var propName:String in pObj) {				trace(propName + "=" + pObj[propName]);			}						*/			if ((vw_num != pObj.width) || (vh_num != pObj.height)) {				vw_num = pObj.width;				vh_num = pObj.height;				sizeVideo(vw_num, vh_num);			}			duration_num = pObj.duration;			setBuffer(buffer);			controlBar.updateDuration(duration_num);			onVideoStatus(null);		}		private function onStatusEvent(pStatusObj:Object):void {			switch (pStatusObj.info.code) {								case "NetStream.Buffer.Empty":				break;								case "NetStream.Buffer.Full":				break;								case "NetStream.Buffer.Flush":				break;								case "NetStream.Failed":				break;								case "NetStream.Publish.Start":				break;								case "NetStream.Publish.BadName":				break;								case "NetStream.Publish.Idle":				break;								case "NetStream.Unpublish.Success":				break;								case "NetStream.Play.Start":				if (isPlaying) {					controlBar.showControls("pause");					showPlayOverlay(false);				} else {					controlBar.showControls("play");					showPlayOverlay(true);				}				break;								case "NetStream.Play.Stop":				dispatchEvent(new Event(Event.COMPLETE, true));				if (loop) {					ns.seek(0);					pause();					resume();				} else {					if (autoRewind) {						ns.seek(0);						pause();						onVideoStatus(null);						if ((!showEndFrames) || (!showFirstFrame)) {							showVideo(false);						} else {							showVideo(true);						}					} else {						if ((!showEndFrames) || (!showLastFrame)) {							showVideo(false);						} else {							showVideo(true);						}					}					showPlayOverlay(true);					controlBar.showControls("play");					isPlaying = false;				}				break;								case "NetStream.Play.Failed":				break;								case "NetStream.Play.StreamNotFound":				break;								case "NetStream.Play.Reset":				break;								case "NetStream.Play.PublishNotify":				break;								case "NetStream.Play.UnpublishNotify":				break;								case "NetStream.Play.InsufficientBW":				break;								case "NetStream.Play.FileStructureInvalid":				trace("The file structure of your video is invalid!");				break;								case "NetStream.Play.NoSupportedTrackFound":				trace("The video doesn't contain any supported tracks");				break;								case "NetStream.Pause.Notify":				break;								case "NetStream.Unpause.Notify":				break;								case "NetStream.Record.Start":				break;								case "NetStream.Record.NoAccess":				break;								case "NetStream.Record.Stop":				break;								case "NetStream.Record.Failed":				break;								case "NetStream.Seek.Failed":				break;								case "NetStream.Seek.InvalidTime":				break;								case "NetStream.Seek.Notify":				break;								case "NetConnection.Call.BadVersion":				break;								case "NetConnection.Call.Failed":				break;								case "NetConnection.Call.Prohibited":				break;								case "NetConnection.Connect.Closed":				break;								case "NetConnection.Connect.Failed":				break;								case "NetConnection.Connect.Success":				break;								case "NetConnection.Connect.Rejected":				break;								case "NetConnection.Connect.AppShutdown":				break;								case "NetConnection.Connect.InvalidApp":				break;								case "SharedObject.Flush.Success":				break;								case "SharedObject.Flush.Failed":				break;								case "SharedObject.BadPersistence":				break;								case "SharedObject.UriMismatch":				break;							}		}		private function onIOError(e:IOErrorEvent):void {			trace(e);		}		private function onVideoStatus(e:Event):void {			if ((vw_num != video.width) || (vh_num != video.height)) {				//sizeVideo(vw_num, vh_num);			}			if (isPlaying) {				showPlayOverlay(false);			}			// Listen for stage display state to display correct icon in control bar			if (fullScreenEnabled) {				if (stage.displayState == StageDisplayState.NORMAL) {					controlBar.fullScreenBtn.setFullScreen(false);				} else {					controlBar.fullScreenBtn.setFullScreen(true);				}			}			loaded_num = ns.bytesLoaded / ns.bytesTotal;			//sizeVideo(vw_num, vh_num);			controlBar.updateElapsed(ns.time);			controlBar.updateDuration(duration_num);			controlBar.statusBar.loadBar.width = loaded_num * lbw_num;			controlBar.statusBar.scrubber.x = Math.round(ns.time / duration_num * lbw_num);			controlBar.statusBar.progressBar.width = controlBar.statusBar.scrubber.x - controlBar.statusBar.progressBar.x;					// Mini Status Bar			miniStatusBar.loadBar.width = loaded_num * miniStatusBar.width;			miniStatusBar.scrubber.x = Math.round(ns.time / duration_num * miniStatusBar.width);			miniStatusBar.progressBar.width = miniStatusBar.scrubber.x - miniStatusBar.progressBar.x;		}		private function onPlayClick(e:MouseEvent):void {			controlBar.showControls("pause");			resume();		}		private function onPlayOverlayClick(e:MouseEvent):void {			controlBar.showControls("pause");			resume();		}		private function onPauseClick(e:MouseEvent):void {			controlBar.showControls("play");			pause();		}		private function onMuteClick(e:MouseEvent):void {			if (audioLevel == 1) {				controlBar.muteBtn.mute();				setAudioLevel(0);			} else {				controlBar.muteBtn.mute(false);				setAudioLevel(1);			}		}		private function onFullScreenClick(e:MouseEvent):void {			if (stage.displayState == StageDisplayState.NORMAL) {				setFullScreen(true);			} else {				setFullScreen(false);			}		}		private function determineControlBarPosition(e:Event):void {			var lVideoLeft_num:Number = videoBG.x;			var lVideoRight_num:Number = videoBG.x + videoBG.width;			var lVideoTop_num:Number = videoBG.y;			var lVideoBottom_num:Number = videoBG.y + videoBG.height;			var lShowControlBar_bol:Boolean = true;						if (cbTimer) {				cbTimer.stop();				cbTimer = null;			}			if ((mouseY >= lVideoTop_num) && (mouseX >= lVideoLeft_num) && (mouseX <= lVideoRight_num) && (mouseY <= lVideoBottom_num)) {				if (showControls) {					lShowControlBar_bol = true;					fadeInControlBar();				} else {					lShowControlBar_bol = false;				}			} else {				lShowControlBar_bol = false;				fadeOutControlBar();				//onScrubberUp(null); // <-- This caused movies using the class to autoPlay no matter what, if the movie was NOT the exact same size as the VM object itself. Not 100% sure why or how.			}			showControlBar(lShowControlBar_bol);		}		private function onControlBarTimerComplete(e:TimerEvent):void {			if (cbTimer) {				cbTimer.stop();				cbTimer = null;			}			fadeOutControlBar();		}		private function onScrubberDown(e:MouseEvent):void {			addVideoStatusListener(false);			addScrubbitListener(true);			controlBar.statusBar.scrubber.startDrag(false, bounds_rect);			addEventListener(MouseEvent.MOUSE_UP, onScrubberUp);		}		private function onScrubberUp(e:MouseEvent):void {			controlBar.showControls("pause");			resume();			addScrubbitListener(false);			addVideoStatusListener(true);			controlBar.statusBar.scrubber.stopDrag();			removeEventListener(MouseEvent.MOUSE_UP, onScrubberUp);		}		private function scrubit(e:Event):void {			ns.seek(Math.floor(((controlBar.mouseX - controlBar.x - (controlBar.statusBar.x)) / lbw_num) * duration_num));			controlBar.statusBar.progressBar.width = controlBar.mouseX - controlBar.statusBar.x;		}		private function onStatusBarClick(e:MouseEvent):void {			ns.seek(Math.floor(((controlBar.mouseX - controlBar.x - (controlBar.statusBar.x)) / lbw_num) * duration_num));			controlBar.statusBar.progressBar.width = controlBar.mouseX - controlBar.statusBar.x;		}		private function onStatusBarMouseMove(e:MouseEvent):void {			controlBar.statusBar.statusLine.x = Math.floor(mouseX - controlBar.x - (controlBar.statusBar.x));			controlBar.statusBar.setTime(Math.floor(((controlBar.mouseX - controlBar.x - (controlBar.statusBar.x)) / lbw_num) * duration_num));		}		private function onStatusBarMouseOver(e:MouseEvent):void {			controlBar.statusBar.statusLine.visible = true;		}		private function onStatusBarMouseOut(e:MouseEvent):void {			controlBar.statusBar.statusLine.visible = false;		}		private function onVideoStart():void {			if (att.onStart != null) {				att.onStart.apply(null, att.onStartParams);			}			addEventListener(Event.COMPLETE, onVideoComplete);		}		private function onVideoComplete(e:Event):void {			if (att.onComplete != null) {				att.onComplete.apply(null, att.onCompleteParams);			}			removeEventListener(Event.COMPLETE, onVideoComplete);		}								// --- Private: Visibility, Size & Position Functions --- //		private function fadeInControlBar():void {			Slider.slide(controlBar, 0.325, {y:Math.ceil(videoBG.y + videoBG.height - controlBar.getHeight())});			Slider.slide(miniStatusBar, 0.325, {y:Math.ceil(videoBG.y + videoBG.height)});						cbTimer = new Timer(3000, 1);			cbTimer.addEventListener(TimerEvent.TIMER_COMPLETE, onControlBarTimerComplete);			cbTimer.start();		}		private function fadeOutControlBar():void {			Slider.slide(controlBar, 0.325, {y:Math.ceil(videoBG.y + videoBG.height)});			Slider.slide(miniStatusBar, 0.325, {y:Math.ceil(videoBG.y + videoBG.height - miniStatusBar.getHeight())});			showMiniStatusBar(showMiniStatus);		}		private function positionControlBar():void {			controlBar.x = 0;			controlBar.y = videoBG.y + videoBG.height - controlBar.getHeight();						// Mini Status Bar			miniStatusBar.x = 0;			miniStatusBar.y = videoBG.y + videoBG.height - miniStatusBar.getHeight();						// Position & Resize Loader Components			controlBar.statusBar.x = Math.round(controlBar.playBtn.width);			controlBar.statusBar.sizer.width = controlBar.statusBar.hit.width = Math.round(controlBar.time.x - controlBar.statusBar.x);			lbw_num = controlBar.statusBar.loadBar.width = Math.round(controlBar.statusBar.sizer.width);						// Set Control Bar Boundaries			var lLeft_num = controlBar.statusBar.sizer.x;			var lRight_num = lLeft_num + controlBar.statusBar.sizer.width;			var lTop_num = controlBar.statusBar.sizer.y;			var lBottom_num = lTop_num;						// Create Rectangle for Scrubber Dragging Boundaries			bounds_rect.left = lLeft_num;			bounds_rect.top = lTop_num;			bounds_rect.right = lRight_num;			bounds_rect.bottom = lBottom_num;		}		private function sizeVideo(pWidth_num:Number, pHeight_num:Number):void {			var vpw_num:Number = videoBG.width;			var vph_num:Number = videoBG.height;			var dw_num:Number = videoBG.width/pWidth_num;			var dh_num:Number = videoBG.height/pHeight_num;						if (autoSize) {				if (dw_num > dh_num) {					video.width = pWidth_num * dh_num;					video.height = pHeight_num * dh_num;				} else if (dh_num > dw_num) {					video.width = pWidth_num * dw_num;					video.height = pHeight_num * dw_num;				} else {					video.width = pWidth_num * dw_num;					video.height = pHeight_num * dw_num;				}			} else {				video.width = videoBG.width;				video.height = videoBG.height;			}						video.x = Math.round((videoBG.width/2) - (video.width/2));			video.y = Math.round((videoBG.height/2) - (video.height/2));						if (isPlaying) {				showVideo();			}		}								// --- Private: Visibility Functions --- //		private function showPlayOverlay(pWhatWay_bol:Boolean):void {			if (playOverlay) {				po.visible = pWhatWay_bol;			} else {				po.visible = false;			}		}			}	}